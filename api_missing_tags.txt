This file contains api tag missing in the project with the explanations for each case.
See https://github.com/ZettaScaleLabs/zenoh-tests/tree/tagging/api_matrix for details.

tags{api.attachment.is_empty(TODO)}
tags{api.attachment.len(TODO)}
Add methods len and is_empty to z_owned_bytes_map_t and to z_attachment_t itself

tags{api.buffer.slices(TODO)}
To be implemented - latest PR by Pierre

tags{api.publisher.delete.attachment.set(N/A)}
tags{api.publisher.delete.encoding.set(N/A)}
Purposedly not added: in Rust they exists only because DeleteBuilder is an alias 
for PutBuilder, but actually they are not used for delete operations.
TODO: consider updating API in Rust: make separate builders for Put and Delete

tags{api.options.locality(See also)}
tags{api.request.allowed_destination.set(TODO)}
tags{api.publisher.allowed_destination.set(TODO)}
tags{api.queryable.allowed_origin.set(TODO)}
tags{api.subscriber.allowed_origin.set(TODO)}
tags{api.publisher.put.allowed_destination.set(TODO)}
tags{api.publisher.delete.allowed_destination.set(TODO)}
Also check, do we need separate option structures for session.put and publisher.put ?
If rust API doesn't allow to change publisher.put options on fly, this is correct.
It's unstable, to be decided do we need to add it to zenoh-c now

tags{api.request.accept_replies.set(TODO)}
tags{api.query.accepts_replies.get(TODO)}
Also unsatble. To be decided.

tags{api.ke_tree(TODO)}
tags{api.ke_tree.create(TODO)}
tags{api.ke_tree.create.with_token(TODO)}
To be implemented in zenoh-c?

tags{api.keyexpr.create.autocanonize(TODO)}
Implement in zenoh-c, it exists in zenoh-pico

tags{api.keyexpr.get_nonwild_prefix(TODO)}
tags{api.keyexpr.is_wild(TODO)}
Actually internal for zenoh, specify this in documentation, remove tags

tags{api.keyexpr.iter(N/A)}
Could be useful, but it's not an essential part of the API.
Actually internal, mark it as it, remove tag

tags{api.keyexpr.relation_to(TODO)}
tags{api.options.keyexpr.set_intersection_level(TODO)}
tags{api.options.keyexpr.set_intersection_level.disjoint(TODO)}
tags{api.options.keyexpr.set_intersection_level.equals(TODO)}
tags{api.options.keyexpr.set_intersection_level.includes(TODO)}
tags{api.options.keyexpr.set_intersection_level.intersects(TODO)}
SetIntersectionLevel is the return value of the relation_to function
Add to zenoh-c

tags{api.keyexpr.strip_prefix(TODO)}
Mark as internal, for plugins mostly

tags{api.liveliness.request.timeout.set(TODO)}
Add option to zenoh-c

tags{api.liveliness.request.channel(N/A)}
Same channel as the query channel, it's avaialable actually

tags{api.scout.channel(N/A)}
May be not worth to add, but possible

tags{api.matching.listener.channel(N/A)}
No support for channel in zenoh-c - same cloning issue as in subscriber

tags{api.liveliness.subscriber.channel(N/A)}
tags{api.subscriber.channel(N/A)}
No support for subscriber channel in zenoh-c yet - no sample clone. Will be
added soon, need to consider adding subscriber channels

Should the channel functionality in zenoh-c (channel for queryable and channel for 'get' request)
be extended to use for all cases above?

tags{api.matching.listener.undeclare(TODO)}
Not needed in zenoh-c, it's used for async only - undeclare can work asynchronously

tags{api.config.create.from_env(TODO)}
Need to be implemented in zenoh-c

tags{api.config.entry.adminspace.permissions.read(TODO)}
tags{api.config.entry.adminspace.permissions.write(TODO)}
tags{api.config.entry.aggregation.publishers(TODO)}
tags{api.config.entry.aggregation.subscribers(TODO)}
tags{api.config.entry.downsampling(TODO)}
tags{api.config.entry.id(TODO)}
tags{api.config.entry.metadata(TODO)}
tags{api.config.entry.plugins(TODO)}
tags{api.config.entry.plugins_search_dirs(TODO)}
tags{api.config.entry.queries_default_timeout(TODO)}
tags{api.config.entry.routing.peer.mode(TODO)}
tags{api.config.entry.routing.router.peers_failover_brokering(TODO)}
tags{api.config.entry.scouting.gossip.autoconnect(TODO)}
tags{api.config.entry.scouting.gossip.enabled(TODO)}
tags{api.config.entry.scouting.multicast.autoconnect(TODO)}
tags{api.config.entry.scouting.multicast.listen(TODO)}
tags{api.config.entry.scouting.timeout(TODO)}
tags{api.config.entry.timestamping(TODO)}
tags{api.config.entry.timestamping.drop_future_timestamp(TODO)}
tags{api.config.entry.transport.auth.pubkey.algorithm(TODO)}
tags{api.config.entry.transport.auth.pubkey.key_size(TODO)}
tags{api.config.entry.transport.auth.pubkey.private_key_file(TODO)}
tags{api.config.entry.transport.auth.pubkey.private_key_pem(TODO)}
tags{api.config.entry.transport.auth.pubkey.public_key_file(TODO)}
tags{api.config.entry.transport.auth.pubkey.public_key_pem(TODO)}
tags{api.config.entry.transport.auth.usrpwd.dictionary_file(TODO)}
tags{api.config.entry.transport.link.protocols(TODO)}
tags{api.config.entry.transport.link.rx(TODO)}
tags{api.config.entry.transport.link.rx.buffer_size(TODO)}
tags{api.config.entry.transport.link.rx.defragmentation_buffer_size(TODO)}
tags{api.config.entry.transport.link.tls.client_auth(TODO)}
tags{api.config.entry.transport.link.tls.client_certificate(TODO)}
tags{api.config.entry.transport.link.tls.client_certificate_base64(TODO)}
tags{api.config.entry.transport.link.tls.client_private_key(TODO)}
tags{api.config.entry.transport.link.tls.client_private_key_base64(TODO)}
tags{api.config.entry.transport.link.tls.root_ca_certificate(TODO)}
tags{api.config.entry.transport.link.tls.root_ca_certificate_base64(TODO)}
tags{api.config.entry.transport.link.tls.server_certificate(TODO)}
tags{api.config.entry.transport.link.tls.server_certificate_base64(TODO)}
tags{api.config.entry.transport.link.tls.server_name_verification(TODO)}
tags{api.config.entry.transport.link.tls.server_private_key(TODO)}
tags{api.config.entry.transport.link.tls.server_private_key_base64(TODO)}
tags{api.config.entry.transport.link.tx.keep_alive(TODO)}
tags{api.config.entry.transport.link.tx.lease(TODO)}
tags{api.config.entry.transport.link.tx.mtu(TODO)}
tags{api.config.entry.transport.link.tx.queue.backoff(TODO)}
tags{api.config.entry.transport.link.tx.queue.size.background(TODO)}
tags{api.config.entry.transport.link.tx.queue.size.control(TODO)}
tags{api.config.entry.transport.link.tx.queue.size.data(TODO)}
tags{api.config.entry.transport.link.tx.queue.size.data_high(TODO)}
tags{api.config.entry.transport.link.tx.queue.size.data_low(TODO)}
tags{api.config.entry.transport.link.tx.queue.size.interactive_high(TODO)}
tags{api.config.entry.transport.link.tx.queue.size.interactive_low(TODO)}
tags{api.config.entry.transport.link.tx.queue.size.real_time(TODO)}
tags{api.config.entry.transport.link.tx.sequence_number_resolution(TODO)}
tags{api.config.entry.transport.link.tx.threads(TODO)}
tags{api.config.entry.transport.link.unixpipe.path(TODO)}
tags{api.config.entry.transport.multicast.compression.enabled(TODO)}
tags{api.config.entry.transport.multicast.join_interval(TODO)}
tags{api.config.entry.transport.multicast.max_sessions(TODO)}
tags{api.config.entry.transport.multicast.qos.enabled(TODO)}
tags{api.config.entry.transport.shared_memory.enabled(TODO)}
tags{api.config.entry.transport.unicast.accept_pending(TODO)}
tags{api.config.entry.transport.unicast.compression(TODO)}
tags{api.config.entry.transport.unicast.compression.enabled(TODO)}
tags{api.config.entry.transport.unicast.lowlatency(TODO)}
tags{api.config.entry.transport.unicast.max_links(TODO)}
tags{api.config.entry.transport.unicast.max_sessions(TODO)}
tags{api.config.entry.transport.unicast.open_timeout(TODO)}
tags{api.config.entry.transport.unicast.qos(TODO)}
tags{api.config.entry.transport.unicast.qos.enabled(TODO)}
Review these tags: they are configuration too:
tags{api.downsampling_item_conf(TODO)}
tags{api.downsampling_rule_conf(TODO)}

Discuss it: this is useful for convenient work with both pico and zenoh-c, but they
have different value format anyway

tags{api.options.downsampling_flow(TODO)}
tags{api.options.downsampling_flow.egress(TODO)}
tags{api.options.downsampling_flow.ingress(TODO)}
Used in config only, need to be added if corresponding config option is added.

tags{api.options.priority.max(TODO)}
tags{api.options.priority.min(TODO)}
tags{api.options.priority.num(TODO)}
Internal ones, to be checked if it's really the case

tags{api.options.query_target.complete(TODO)}
To be discussed: was purposedly not exposed to zenoh-c, feature is not actually supported

tags{api.sample.source_info.get(TODO)}
tags{api.sample.source_info.set(TODO)}
tags{api.options.source_info(TODO)}
tags{api.options.source_info.source_id(TODO)}
tags{api.options.source_info.source_sn(TODO)}
Unstable, to be decided to include or not

tags{api.options.what_am_i.to_str(TODO)}
Consider exposing - examples reimplements it all the time

tags{api.publisher.send_matching_status_request(TODO)}
To be added to zenoh-c

tags{api.reply.replier_id.get(TODO)}
Expose to zenoh-c, after reply rework

tags{api.sample.timestamp.ensure(TODO)}
Find a way to expose: it takes mutable sample, which doesn't work for zenoh-c

tags{api.scout.stop(TODO)}
No sense for zenoh-c - scout function blocks the thread

tags(api.query.selector.get(TODO))
tags{api.selector(TODO)}
tags{api.selector.create(TODO)}
tags{api.selector.keyexpr.get(TODO)}
tags{api.selector.keyexpr.set(TODO)}
tags{api.selector.parameters.get(TODO)}
tags{api.selector.parameters.set(TODO)}
tags{api.selector.time_range.get(TODO)}
tags{api.selector.time_range.remove(TODO)}
tags{api.selector.time_range.set(TODO)}
tags{api.options.selector.time_range_key(TODO)}
Selector exists in rust only for set of utiulity url functions. As they are
not exposed to zenoh-c, no need to have separate Selector structure

tags{api.session.config.set(TODO)}
tags{api.session.config.get(TODO)}
Think about adding config accessor method to the session

tags{api.timestamp.create.now(TODO)}

tags{api.session.hlc(N/A)}
HLC is Rust specific. But need to check why `new_reception_timestamp` (tags{api.timestamp.create.now(See also)}) does not use it

tags{api.what_am_i_matcher(TODO)}
tags{api.what_am_i_matcher.create.client(TODO)}
tags{api.what_am_i_matcher.create.empty(TODO)}
tags{api.what_am_i_matcher.create.peer(TODO)}
tags{api.what_am_i_matcher.create.router(TODO)}
tags{api.what_am_i_matcher.is_empty(TODO)}
tags{api.what_am_i_matcher.matches(TODO)}
tags{api.what_am_i_matcher.to_str(TODO)}
Internal thing?

tags{api.zid.create.rand(TODO)}
tags{api.zid.max_size(TODO)}
tags{api.zid.size(TODO)}
tags{api.zid.to_keyexpr(TODO)}
tags{api.zid.to_le_bytes(TODO)}
To be decided